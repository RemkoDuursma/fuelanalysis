---
title: "Fuel prices in NSW - Part 1"
author: "Remko Duursma"
date: "19 December 2017"
output: html_document
---

```{r setup, include=FALSE, cache=FALSE}
library(knitr)
opts_chunk$set(echo = TRUE, eval=FALSE)
read_chunk('read_andgeo_fuelprices.R')
```

```{r getdata_prep, include=FALSE, eval=FALSE}
# Do this once or when needed (one minute)
source("read_andgeo_fuelprices.R")
save.image("cache/fuel_objects.RData")
```

```{r loaddata, include=FALSE, eval=TRUE}
load("cache/fuel_objects.RData")
```

```{r loadpackages}
pacman::p_load(oz, magicaxis)
```


# Getting the Data

The FuelCheck service in New South Wales, Australia, provides real-time data on fuel prices at service stations across the state. [This page](https://data.nsw.gov.au/data/dataset/fuel-check) contains information, as well as monthly files containing fuel prices for all service stations, for all fuel types. The first step is to download all `xlsx` files, and save them locally. We then use `readxl` to read them all, and `dplyr` to tidy things up.

```{r load_packages}

```

And then

```{r read_fuel_raw}

```

You can skip this step as I have bundled the clean dataset in the R package `fuelpricensw`, which is available on [this Github repos](https://github.com/RemkoDuursma/fuelpricensw). 

```{r}
devtools::install_github("remkoduursma/fuelpricensw")
library(fuelpricensw)
data(fuel)
```



## Geocoding

The fuel price dataset contains street addresses of all service stations, but we would like to include latitude and longitude, so that other spatial attributes can easily be looked up. Here I used Google's geocode service, as made easily available in the `ggmap` package.

```{r get_lat_long}

```

Get rid of USA addresses. When geocode does not find a good match, Google returns some random address in the USA. Better approaches exist here, like the geonames service to find the country code.

```{r filter_locs}
 
```


## Distance to nearest competitor

```{r, nearest_neighbours}

```


The distance to the nearest next service station peaks at 1km (1000m). The most remote service station appears to be `r locs[which.max(locs$dist_1),"Address"]`, though recall geocoding failed for some stations, so we don't have distance to all stations.

```{r}
hist(log10(locs$dist_1), breaks=100, axes=FALSE,
     main="", col="cornflowerblue",
     xlab="Distance to nearest service station (m)")
magicaxis::magaxis(side=1, unlog=1)
axis(2)
```

## Area served : Voronoi polygons


```{r plain_voronoi}
```

```{r fig.width=10, fig.height=8}
par(mar=c(3,3,1,1))
with(locs, plot(lon, lat, pch=16, col="red", xlab="", ylab=""))
plot(v, wlines="tess", wpoints="none", lty=1, col="grey", add=TRUE)
with(locs, points(lon, lat, pch=16, col="red"))

```


```{r buffer_voronoi}
```


```{r}
par(mar=c(0,0,0,0))
plot(z)
```


```{r}
library(oz)

oz(sections=c(4,13:15))
with(locs, points(lon,lat,pch=19, col=rev(heat.colors(10))[cut(log(area_voronoi),10)]))

```


## Remoteness, distance to coast

Eventually I want to build a model that predicts fuel price based on location, and time of year. To do so, we have to start adding some features of interest. The Atlas of Living Australia provides a 'remoteness index', which seems interesting since at first sight fuel prices are much higher for more remote locations. Though the ALA provides API services, I did this the quick way by visiting [this page](http://spatial.ala.org.au/webportal/), uploading a CSV with lat and long, and downloading a CSV file with a remoteness index, and the distance to coast.

```{r remoteness}
```


```{r}
# Figure
library(oz)
oz(sections=c(4, 13:15))
cols <- colorRampPalette(c("yellow","darkorange","red"))(10)
with(remo, points(lon,lat, pch=19, col=cols[cut(log(remoteness+1), 10)]))

```


## Combined dataset

```{r final_merge}

```


















